1. 현재 구조 유지 + 데이터 동기화 전략 개선 (추천)
   서비스 분리의 장점을 유지하면서 불편함을 최소화:
   A. Shared Database 패턴
   공유 MySQL: 두 서버가 같은 MySQL 인스턴스 사용
   도메인별 테이블 분리:
   api-server: performances, venues, sessions (읽기 전용)
   ticket-server: reservations, rankings (쓰기 권한)
   장점: 데이터 중복 없음, 실시간 동기화
   단점: 데이터베이스가 단일 장애점
   B. CQRS 패턴

ticket-server (Command) → Redis → MySQL → api-server (Query)
ticket-server: 빠른 예매 처리 (Redis)
백그라운드 작업: Redis → MySQL 비동기 저장
api-server: MySQL에서 통계/랭킹 조회
장점: 각 서버의 책임이 명확, 성능 최적화
단점: 약간의 데이터 지연 2. 이벤트 기반 아키텍처

// ticket-server에서 예매 완료 시
eventEmitter.emit('reservation.completed', {
userId, sessionId, seats, completionTime
});

// api-server가 이벤트 구독하여 통계 업데이트
구현 방법:
Redis Pub/Sub
RabbitMQ/Kafka 같은 메시지 큐
장점: 느슨한 결합, 확장 가능
단점: 인프라 복잡도 증가 3. BFF (Backend For Frontend) 패턴

Frontend → Gateway → api-server (일반)
→ ticket-server (티켓팅)
API Gateway가 라우팅 처리
프론트엔드는 단일 엔드포인트만 호출
장점: 프론트엔드 간소화
단점: Gateway 관리 필요 4. Monorepo + Shared Package

packages/
shared-types/ # 공통 타입
shared-database/ # DB 모델, 마이그레이션
api-server/
ticket-server/
현재 @beastcamp/shared-types처럼 확장:
@beastcamp/shared-database - TypeORM 엔티티
@beastcamp/shared-services - 공통 로직
실용적인 단계별 접근 (추천)
Phase 1: 지금 (빠른 구현)

// ticket-server에서 예매 완료 시
await redis.set(`ranking:session:${sessionId}:${userId}`, JSON.stringify({
rank, userId, queuePosition, seatCount, completionTime
}));

// api-server는 ticket-server API 프록시
// 또는 같은 Redis 인스턴스 읽기
Phase 2: MySQL 도입 시

// ticket-server
await redis.set(...); // 빠른 예매
await mysqlQueue.add({ ...data }); // 비동기 저장

// Worker 프로세스
mysqlQueue.process(async (job) => {
await db.reservations.create(job.data);
});

// api-server
// MySQL에서 직접 조회
Phase 3: 스케일 고려 시
Redis Cluster
MySQL Read Replica
이벤트 기반 동기화
지금 바로 할 수 있는 개선

// shared 패키지 활용
// packages/shared-database/entities/reservation.entity.ts
export class Reservation {
@Column() userId: string;
@Column() sessionId: number;
@Column() completionTime: number;
// ...
}

// 양쪽 서버에서 import
import { Reservation } from '@beastcamp/shared-database';
결론
현재 상황에서는:
✅ 서비스 분리 유지 (티켓팅 안정성 확보)
✅ MySQL 공유 사용 (데이터 중복 최소화)
✅ ticket-server는 Redis로 빠른 처리
✅ 백그라운드로 MySQL 동기화
✅ api-server는 MySQL에서 통계 조회

---

개발 환경 vs 배포 환경 DB 구성
일반적인 방식:
개발 환경:
로컬 MySQL/PostgreSQL 사용 (Docker Compose로 실행)
각 개발자마다 독립적인 DB 인스턴스
shared-database는 **테이블 스키마(엔티티)**만 공유하고, DB 인스턴스는 별도
배포 환경:
CloudSQL, RDS 같은 관리형 DB 서비스
api-server와 ticket-server가 같은 DB 인스턴스를 공유
하지만 **같은 스키마(엔티티)**를 사용
shared-database 패키지의 역할:

// shared-database는 "스키마 정의"만 공유
// DB 인스턴스 자체를 공유하는 게 아닙니다!

// packages/shared-database/src/entities/reservation.entity.ts
@Entity('reservations') // ← 테이블 구조만 정의
export class Reservation {
@Column() userId: string;
// ...
}

// ticket-server와 api-server가 같은 엔티티를 import
// 각자의 TypeORM 연결로 같은 MySQL 인스턴스에 접근
그럼 현재 작업을 계속하되, 설명을 더 명확하게 드릴게요. 현재 구조:

개발 환경:

- MySQL (Docker): localhost:3306
  ├─ ticket-server → 연결
  └─ api-server → 연결
- shared-database: 엔티티 정의만 제공

배포 환경:

- CloudSQL: xxx.xxx.xxx.xxx:3306
  ├─ ticket-server → 연결
  └─ api-server → 연결
- shared-database: 동일한 엔티티 사용

